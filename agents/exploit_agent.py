from re import L
from tools.http_tools import *
from tools.view_file_tools import *
from tools.view_directory_tools import *

load_dotenv()
# Define tools and LLM
tools = [
    HttpTool(),
    ViewFileTool(),
    ViewFileLinesTool(),
    DirectoryListingTool(),
    FileListingTool(),
    DirectoryStructureTool(),
]
llm = ChatBedrock(
    model_id="us.anthropic.claude-3-5-haiku-20241022-v1:0",
    model_kwargs={"temperature": 0.6},
)
# Define instructions and prompt
prompt = """
You are an expert security researcher specializing in identifying and exploiting Server-Side Request Forgery (SSRF) vulnerabilities in codebases. Your task is to analyze the provided codebase, looking for any areas where user input is used to make HTTP requests, especially via libraries or functions that fetch remote resources.

TOOLS:
------

You have access to the following tools:

{tools} 

You also have access to an HTTPTool, which allows you to execute arbitrary HTTP requests. Use this tool to craft and execute requests that could exploit SSRF vulnerabilities, such as accessing internal network resources, cloud metadata endpoints, or other sensitive services that should not be exposed externally. 
The vulnerable web app is running at http://localhost:3000, use this as the base URL for your requests.

To use a tool, please use the following format:
```
Thought: Do I need to use a tool? Yes
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
```

When you have a response to say to the Human, 
or if you do not need to use a tool, 
you MUST use the format:

```
Thought: Do I need to use a tool? No
Final Answer: [your response here]

For each potential SSRF vulnerability you find:
- Describe the vulnerable code and explain why it is susceptible to SSRF.
- Exploit the SSRF vulnerability by sending a payload throuhg the HTTPTool.
- Suggest possible mitigations to prevent SSRF in the affected code.

Be thorough, creative, and document your findings and exploitation steps clearly.

BEGIN!

New input: {input}
{agent_scratchpad}
"""
prompt = PromptTemplate.from_template(prompt)


def analyze_code(input_code: str) -> dict:
    """
    Analyze the given code using the agent_executor and return the result.
    """
    # Use return_intermediate_steps=True to capture the thinking process
    response = agent_executor.invoke(
        {"input": input_code}, return_intermediate_steps=True
    )

    # Print the thinking steps for visibility
    if "intermediate_steps" in response and response["intermediate_steps"]:
        print("\nðŸ§  Agent Thinking Process:")
        print("-" * 40)
        for i, (action, observation) in enumerate(response["intermediate_steps"], 1):
            print(f"Step {i}:")
            print(f"  Action: {action.tool} - {action.tool_input}")
            print(f"  Observation: {observation}")
            print()

    return response


agent = create_react_agent(llm, tools, prompt)
agent_executor = AgentExecutor(
    agent=agent, tools=tools, verbose=True, handle_parsing_errors=True
)
# Simple LangGraph integration
try:
    from typing import TypedDict

    from langgraph.graph import END, StateGraph

    class AgentState(TypedDict):
        input: str
        output: str

    def agent_node(state: AgentState) -> AgentState:
        """Run the ReAct agent"""
        result = agent_executor.invoke({"input": state["input"]})
        return {"input": state["input"], "output": result["output"]}

    # Create simple LangGraph workflow
    workflow = StateGraph(AgentState)
    workflow.add_node("agent", agent_node)
    workflow.set_entry_point("agent")
    workflow.add_edge("agent", END)

    # Compile the graph
    langgraph_app = workflow.compile()

    def analyze_code_with_langgraph(input_code: str) -> dict:
        """Analyze code using LangGraph wrapper around ReAct agent"""
        result = langgraph_app.invoke({"input": input_code})
        return result

except ImportError:
    print("LangGraph not available. Using standard ReAct agent only.")

    def analyze_code_with_langgraph(input_code: str) -> dict:
        return analyze_code(input_code)


if __name__ == "__main__":
    print("ðŸš€ ReAct Agent SAST Demo")
    print("=" * 50)

    # Task for autonomous analysis
    analysis_task = "Analyze the code in ./juice_shop.faiss/ for SSRF vulnerabilities. Start by exploring the directory structure to understand the codebase."

    # Standard ReAct agent
    print("\nðŸ“‹ Standard ReAct Agent:")
    result = analyze_code(analysis_task)
    print(result)

    # LangGraph wrapped ReAct agent
    print("\nðŸ”„ LangGraph ReAct Agent:")
    langgraph_result = analyze_code_with_langgraph(analysis_task)
    print(langgraph_result)
